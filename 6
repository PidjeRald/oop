#pragma once
#include "Node.h"
#include <iostream>
using namespace::std;

template<typename T>
class List {
	Node<T>* head;
	unsigned int size;
public:
	List();
	List(const List<T>& other);
	~List();

	bool find(T data);
	unsigned int getSize();

	T& operator [] (const int i);
	List<T>& operator = (const List<T>& other);
	friend ostream& operator <<<T> (ostream& os, List<T>& other);

	void pushFront(T data);
	void pushBack(T data);
	void pushBefore(unsigned int i, T data);
	void pushAfter(unsigned int i, T data);

	void popFirst();
	void popLast();
	void popIndex(unsigned int i);
	void clear();
	bool isEmpty();
};

template<typename T>
inline List<T>::List() {
	size = 0;
	head = nullptr;
}

template<typename T>
inline List<T>::List(const List<T>& other) {
	size = 0;
	head = nullptr;
	for (int i = 0; i < other.size; i++) {
		pushBack(other[i]);
	}
}

template<typename T>
inline List<T>::~List() {
	clear();
}

template<typename T>
inline bool List<T>::find(T data) {
	for (int i = 0; i < size; i++) {
		if ((*this)[i] == data) {
			pushFront(data);
			popIndex(i + 1);
			return 1;
		}
	}
	return 0;
}

template<typename T>
inline unsigned int List<T>::getSize() {
	return size;
}

template<typename T>
inline T& List<T>::operator [] (const int i) {
	Node<T> *t = head;
	int count = 0;
	while (t) {
		if (count == i)
			return t->data;
		t = t->next;
		count++;
	}
}

template<typename T>
inline List<T>& List<T>::operator = (const List<T>& other) {
	Node<T>* thisTemp = head, * otherTemp = other.head;
	if (size <= other.size) {
		while (thisTemp) {
			thisTemp->data = otherTemp->data;
			thisTemp = thisTemp->next;
			otherTemp = otherTemp->next;
		}
		while (otherTemp) {
			pushBack(otherTemp->data);
			otherTemp = otherTemp->next;
		}
	}
	else {
		while (otherTemp) {
			thisTemp->data = otherTemp->data;
			thisTemp = thisTemp->next;
			otherTemp = otherTemp->next;
		}
		while (size != other.size) {
			popLast();
		}
	}
	return *this;
}

template<typename T>
inline ostream& operator << (ostream& os, List<T>& other) {
	if (other.size == 0)
		os << "List is empty.\n";
	else
		for (int i = 0; i < other.size; i++) {
			os << i << ". " << other[i] << "\n";
		}
	return os;
}

template<typename T>
inline void List<T>::pushFront(T data) {
	head = new Node<T>(data, head);
	size++;
}

template<typename T>
inline void List<T>::pushBack(T data) {
	if (head == nullptr)
		head = new Node<T>(data);
	else {
		Node<T>* t = head;
		while (t->next != nullptr)
			t = t->next;
		t->next = new Node<T>(data);
	}
	size++;
}

template<typename T>
inline void List<T>::pushBefore(unsigned int i, T data) {
	if (i == 0) {
		pushFront(data);
	}
	else
		if (i > size)
			pushBack(data);
		else {
			Node<T>* t = head;
			unsigned int count = 0;
			while (count + 1 != i) {
				t = t->next;
				count++;
			}
			t->next = new Node<T>(data, t->next);
			size++;
		}
}

template<typename T>
inline void List<T>::pushAfter(unsigned int i, T data) {
	if (i >= size)
		pushBack(data);
	else {
		Node<T>* t = head;
		unsigned int count = 0;
		while (count != i) {
			t = t->next;
			count++;
		}
		t->next = new Node<T>(data, t->next);
		size++;
	}
}

template<typename T>
inline void List<T>::popFirst() {
	if (head) {
		Node<T>* t = head;
		head = head->next;
		t->next = nullptr;
		delete t;
		size--;
	}
}

template<typename T>
inline void List<T>::popLast() {
	if (head) {
		if (head->next) {
			Node<T>* t = head;
			while (t->next->next)
				t = t->next;
			delete t->next;
			t->next = nullptr;
			size--;
		}
		else
			popFirst();
	}
}

template<typename T>
inline void List<T>::popIndex(unsigned int i) {
	if (head) {
		if (i == 0)
			popFirst();
		else
			if (i >= size - 1)
				popLast();
			else {
				Node<T>* t = head;
				unsigned int count = 0;
				while (count + 1 != i) {
					t = t->next;
					count++;
				}
				Node<T>* deadNode = t->next;
				t->next = t->next->next;
				deadNode->next = nullptr;
				delete deadNode;
				size--;
			}
	}
}

template<typename T>
inline void List<T>::clear() {
	while (head)
		popFirst();
	size = 0;
}

template<typename T>
inline bool List<T>::isEmpty()
{
	return (head == nullptr);
}

------------------------------------------------------------------------------------

#pragma once 

template<typename T>
class Node {
	template<typename T>
	friend class List;
	T data;
	Node* next;
public:
	Node(T data, Node* next = nullptr);
};

template<typename T>
Node<T>::Node(T data, Node* next) {
	this->data = data;
	this->next = next;
}

------------------------------------------------------------------------------------

#include "List.h"
using namespace::std;

int main() {
    List<int> l,l2;
    int x;
    int n;
    int choice = 0;
    cout << "1.find(x)\n2.pushFront(x)\n3.pushBack(x)\n4.pushBefore(n,x)\n5.pushAfter(n,x)\n6.popFirst()\n7.popLast()\n8.popIndex(x)\n9.clear()\n10.l2 = l\n11.cout << l\n12.cout << l2\n\n";
    do {
        cin >> choice;
        switch (choice) {
        case 1:
            cout << "x = ";
            cin >> x;
            cout << l.find(x) << endl;
            break;
        case 2:
            cout << "x = ";
            cin >> x;
            l.pushFront(x);
            break;
        case 3:
            cout << "x = ";
            cin >> x;
            l.pushBack(x);
            break;
        case 4:
            cout << "n = ";
            cin >> n;
            cout << "x = ";
            cin >> x;
            l.pushBefore(n,x);
            break;
        case 5:
            cout << "n = ";
            cin >> n;
            cout << "x = ";
            cin >> x;
            l.pushAfter(n,x);
            break;
        case 6:
            l.popFirst();
            break;
        case 7:
            l.popLast();
            break;
        case 8:
            cout << "x = ";
            cin >> x;
            l.popIndex(x);
            break;
        case 9:
            l.clear();
            break;
        case 10:
            l2 = l;
            break;
        case 11:
            cout << l;
            break;
        case 12:
            cout << l2;
            break;
        default:
            break;
        }
    } while (choice != 13);
    return 0;
}
